# Copyright REFITT Team 2019. All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it under the
# terms of the Apache License (v2.0) as published by the Apache Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE. See the Apache License for more details.
#
# You should have received a copy of the Apache License along with this program.
# If not, see <https://www.apache.org/licenses/LICENSE-2.0>.

"""User/identity authorization management."""

# standard libs
import secrets
from datetime import datetime

# internal libs
from ..core.logging import Logger
from .interface import user, execute


# initialize module level logger
log = Logger.with_name(f'refitt.database.auth')


def gen_key() -> str:
    """
    Generate a new auth_key.

    Returns
    -------
    auth_key: str
        A 16-character hexadecimal string.
    """
    return secrets.token_hex(8)


def gen_auth(user_id: int, level: int = None, key: str = None) -> dict:
    """
    Generate a new set of user authentication credentials.

    Arguments
    ---------
    user_id: int
        The `user_id` to associate with these credentials.

    level: int (default: None)
        The `auth_level` to use. If None, check for current level.

    key: str (default: None)
        The `auth_key` this new token is to be associated with.
        If no key is given, the database will be checked for an existing key.
        If no key exists for that user, a new one will be generated.

    Returns
    -------
    auth: dict
        A dict with auth_level, auth_key, auth_token, auth_valid, auth_time, and user_id.
        The auth_id is auto-generated by the database upon insertion; auth_valid is always set to True.

    See also
    --------
    gen_key() -> str
        Generate a new auth_key.
    """

    # query for all existing key/token pairs, order by time
    log.debug(f'checking for existing key/token pairs for user_id={user_id}')
    auth = user['auth'].select(where=[f'user_id = {user_id}'])
    auth = auth.sort_values(by='auth_time', ascending=False).reset_index(drop=True)
    log.debug(f'found {len(auth)} existing key/token pairs for user_id={user_id}')

    if level is None:
        if auth.empty:
            raise ValueError('No previous auth_level exists')
        level, = auth.auth_level.unique()  # should only be a single level for a given user
        log.debug(f'defaulting auth_level={level} for user_id={user_id}')

    if level < 0:
        raise ValueError(f'gen_auth: expected a non-negative integer for `level`, given {level}.')
    if user_id < 0:
        raise ValueError(f'gen_auth: expected a non-negative integer for `user_id`, given {user_id}.')
    if key is not None and len(key) != 16:
        raise ValueError(f'gen_auth: expected a 16-character string for `key`.')
    log.debug(f'checking for user_id={user_id}')
    if user['user'].select(where=[f'user_id = {user_id}']).empty:
        raise ValueError(f'gen_auth: user_id={user_id} not found in "user"."user".')

    if key is None:
        if auth.empty:
            log.debug(f'generating new auth key for user_id={user_id}')
            key = gen_key()
        else:
            log.debug(f'using latest valid auth key for user_id={user_id}')
            key = auth.loc[0, 'auth_key']

    return {'auth_level': level,
            'auth_key': key,
            'auth_token': secrets.token_hex(32),
            'auth_valid': True,
            'auth_time': datetime.now(),
            'user_id': user_id
            }


def put_auth(auth: dict) -> None:
    """
    Take generated `auth` dictionary and insert into database.

    Arguments
    ---------
    auth: dict
        Result from `refitt.database.auth.gen_auth`.

    See also:
    refitt.database.auth.gen_auth
    """
    user['auth'].insert_record(**auth)


def from_key(key: str, limit: int = None) -> bool:
    """
    Fetch most recent valid credentials.

    Arguments
    ---------
    key: str
        The 16-bit auth_key to search for.

    limit: int (default: None)
        Limit the number of returned records.

    Returns
    -------
    auth: dict
        Most recent valid auth record.
    """
    auth = user['auth'].select(where=[f"auth_key = '{key}'", f"auth_valid = true"],
                               orderby='auth_time', ascending=False)

    return auth if not auth.empty else None


def from_user(user_id: str, limit: int = None) -> bool:
    """
    Fetch most recent valid credentials.

    Arguments
    ---------
    user_id: str
        The user_id to search for.

    limit: int (default: None)
        Limit the number of returned records.

    Returns
    -------
    auth: dict
        Most recent valid auth record.
    """
    auth = user['auth'].select(where=[f"user_id = {user_id}", f"auth_valid = true"],
                               orderby='auth_time', ascending=False)

    return auth if not auth.empty else None


def check_valid(key: str, token: str, level: int) -> bool:
    """
    Check if given key/token pair is present, valid, and satisfies the given level.
    The `level` just has to be greater than or equal to the user's auth_level.
    """
    auth = from_key(key)
    if auth.empty:
        return False
    auth = auth[auth.auth_token == token]
    if auth.empty:
        return False
    auth = auth.iloc[0]
    if auth.auth_level > level:
        return False
    return True


INVALIDATE_AUTH_QUERY = """
UPDATE "user"."auth"
SET
    auth_valid = false
WHERE
    user_id = {user_id}
"""


INVALIDATE_AUTH_QUERY_NOT_LATEST = INVALIDATE_AUTH_QUERY + """
AND auth_id != {auth_id}
"""


def set_invalid(user_id: int, keep_latest: bool = False) -> None:
    """
    Mark all existing credentials as invalid, except for the most
    recent if specified.
    """
    if not keep_latest:
        execute(INVALIDATE_AUTH_QUERY.format(user_id=user_id))
    else:
        auth_id = from_user(user_id, limit=1).reset_index().iloc[0].auth_id
        execute(INVALIDATE_AUTH_QUERY_NOT_LATEST.format(user_id=user_id, auth_id=auth_id))


DELETE_AUTH_QUERY = """
DELETE FROM "user"."auth"
WHERE user_id = {user_id} AND
      auth_valid = false;
"""

def del_auth(user_id: int) -> None:
    """
    Remove all credentials from database for the given `user_id` where
    `auth_valid = false`.
    """
    execute(DELETE_AUTH_QUERY.format(user_id=user_id))