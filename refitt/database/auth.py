# Copyright REFITT Team 2019. All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it under the
# terms of the Apache License (v2.0) as published by the Apache Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE. See the Apache License for more details.
#
# You should have received a copy of the Apache License along with this program.
# If not, see <https://www.apache.org/licenses/LICENSE-2.0>.

"""User/identity authorization management."""

# standard libs
import json
import secrets
from datetime import datetime

# type annotations
# from typing import Tuple, Dict, Any, List

# internal libs
from ..core.logging import logger
from .interface import user, insert

# external libs
from pandas import DataFrame


# initialize module level logger
log = logger.with_name(f'refitt.database.auth')


def gen_key() -> str:
    """
    Generate a new auth_key.

    Returns
    -------
    auth_key: str
        A 16-character hexadecimal string.
    """
    return secrets.token_hex(8)


def gen_auth(user_id: int, level: int = None, key: str = None) -> dict:
    """
    Generate a new set of user authentication credentials.

    Arguments
    ---------
    user_id: int
        The `user_id` to associate with these credentials.

    level: int (default: None)
        The `auth_level` to use. If None, check for current level.

    key: str (default: None)
        The `auth_key` this new token is to be associated with.
        If no key is given, the database will be checked for an existing key.
        If no key exists for that user, a new one will be generated.

    Returns
    -------
    auth: dict
        A dict with auth_level, auth_key, auth_token, auth_valid, auth_time, and user_id.
        The auth_id is auto-generated by the database upon insertion; auth_valid is always set to True.
    
    See also
    --------
    gen_key() -> str
        Generate a new auth_key.
    """

    # query for all existing key/token pairs, order by time
    log.debug(f'checking for existing key/token pairs for user_id={user_id}')
    auth = user['auth'].select(where=[f'user_id = {user_id}'])
    auth = auth.sort_values(by='auth_time', ascending=False).reset_index(drop=True)
    log.debug(f'found {len(auth)} existing key/token pairs for user_id={user_id}')

    if level is None:
        if auth.empty:
            raise ValueError('No previous auth_level exists')
        level, = auth.auth_level.unique()  # should only be a single level for a given user
        log.debug(f'defaulting auth_level={level} for user_id={user_id}')
    
    if level < 0:
        raise ValueError(f'gen_auth: expected a non-negative integer for `level`, given {level}.')
    if user_id < 0:
        raise ValueError(f'gen_auth: expected a non-negative integer for `user_id`, given {user_id}.')
    if key is not None and len(key) != 16:
        raise ValueError(f'gen_auth: expected a 16-character string for `key`.')
    log.debug(f'checking for user_id={user_id}')
    if user['user'].select(where=[f'user_id = {user_id}']).empty:
        raise ValueError(f'gen_auth: user_id={user_id} not found in "user"."user".')

    if key is None:
        if auth.empty:
            log.debug(f'generating new auth key for user_id={user_id}')
            key = gen_key()
        else:
            log.debug(f'using latest valid auth key for user_id={user_id}')
            key = auth.loc[0, 'auth_key']

    return {'auth_level': level,
            'auth_key': key,
            'auth_token': secrets.token_hex(32),
            'auth_valid': True,
            'auth_time': datetime.now(),
            'user_id': user_id
            }
